---
import AnimateText from "../components/AnimateText.astro";
import HorizontalScrollContainer from "../components/HorizontalScrollContainer.astro";
import ArrowIcon from "../assets/Arrow.svg?raw";

const content = [
  [
    "Why care about taxes?",
    "Global sovereign debt is fast rising on the global agenda due to impending debt crises in many developing countries. Debt Justice estimates that 54 countries are currently in debt crisis, while another 57 countries are at risk of a public or private debt crisis or both. Servicing debt eats up government budgets, meaning little is left to meet local needs.",
    "#",
  ],
  [
    "Why care about sovereign debt?",
    "Global sovereign debt is fast rising on the global agenda due to impending debt crises in many developing countries. Debt Justice estimates that 54 countries are currently in debt crisis, while another 57 countries are at risk of a public or private debt crisis or both. Servicing debt eats up government budgets, meaning little is left to meet local needs.",
    "#",
  ],
  [
    "Why care about accountable, effective public spending?",
    "Too often public resources are being spent unfairly and ineffectively, leaving millions of people without access to quality public goods and services. This transparency and accountablekind of spending is also more immune to corruption.",
    "#",
  ],
];
---

<section id="challenge-presentation" class="my-24">
  <HorizontalScrollContainer
    className="block bg-white overflow-y-hidden md:flex md:h-svh md:items-center md:pl-[max(1rem,(100vw_-_1280px)_/_2)]"
  >
    <h3 class="sr-only">
      <AnimateText textList={["The Challenge"]} />
    </h3>
    <ul
      class="challenge-content flex flex-col gap-y-16 px-6 md:flex-row md:pr-[max(1rem,(100vw_-_1280px)_/_2)]"
    >
      {
        content.map(([title, p]) => (
          <li class="z-10 flex flex-col-reverse justify-center gap-12 text-center opacity-0 first:opacity-100 md:mr-[45vw] md:min-w-[574px] md:flex-col md:text-left md:last:mr-0 md:odd:flex-col-reverse">
            <div>
              <h3 class="mb-6 text-2xl font-bold uppercase tracking-tight text-[#1672F7] md:text-3xl">
                <AnimateText textList={[title]} />
              </h3>
              <p class="text-lg">{p}</p>
              <a
                href="#"
                class="group mx-auto mt-4 flex w-fit items-center gap-x-5 rounded-full bg-[#1672F7] p-1 pl-6 text-base text-white md:mx-0"
              >
                <span> More details </span>
                <span class="rotate-45 text-[#1672F7] transition-transform group-hover:rotate-0 [&>svg]:size-9 [&>svg]:fill-white">
                  <Fragment set:html={ArrowIcon} />
                </span>
              </a>
            </div>
            <div class="mx-auto aspect-square w-64 rounded-3xl bg-[#CDF1F3] md:mx-0" />
          </li>
        ))
      }
    </ul>
    <svg
      class="rope hidden md:block left-0 md:absolute"
      width="2577"
      height="390"
      viewBox="0 0 1800 333"
      preserveAspectRatio="none"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M0 1C332.5 1 474 315.5 838 331C1202 346.5 1440 1 1746.5 1C2053 1 2239 331 2577 331"
        stroke="#1672F7"
        stroke-width="2"></path>
    </svg>
  </HorizontalScrollContainer>
</section>

<script>
  import { animate, scroll, inView } from "motion";

  const cleanupFunctions: VoidFunction[] = [];

  initEventListeners();
  document.addEventListener("astro:after-swap", initEventListeners);
  document.addEventListener("astro:before-preparation", () => {
    cleanupFunctions.forEach((fn) => fn());
    cleanupFunctions.length = 0;
  });

  function initEventListeners() {
    const listElements = document.querySelectorAll(
      "#challenge-presentation .challenge-content > li"
    ) as NodeListOf<HTMLElement>;

    listElements.forEach((listElement, index) => {
      if (index === 0) return;
      const inViewCallback = inView(
        listElement,
        () => {
          console.log("in view");
          animate(
            listElement,
            { opacity: [0, 1], x: [100, 0] },
            { ease: "circInOut" }
          );
        },
        {
          amount: window.innerWidth < 768 ? 0.3 : 1,
        }
      );

      cleanupFunctions.push(inViewCallback);
    });

    const rope = document.querySelector(".rope") as SVGSVGElement | null;
    const ropePath = rope?.querySelector("path") as SVGPathElement | null;

    if (!rope || !ropePath) return;
    const wrapper = document.querySelector(
      "#challenge-presentation .horizontal-scroll-content-wrapper"
    ) as HTMLUListElement;

    const ropePathAnimation = animate(
      ropePath,
      {
        pathLength: [0, 1],
      },
      {
        ease: "linear",
      }
    );

    const ropeXTranslation = 300;
    const ropeAnimation = animate(rope, {
      x: [0, ropeXTranslation],
    });

    ropePathAnimation.pause();
    ropeAnimation.pause();

    const scrollCallback = scroll(() => {
      const scroll = wrapper.scrollLeft;
      const width = wrapper.scrollWidth;
      const mult = 0.4;

      const progress = scroll / width;
      ropePathAnimation.time = progress * mult;
      ropeAnimation.time = ropePathAnimation.time;
    });

    cleanupFunctions.push(scrollCallback);

    calculateRopeWidth();
    window.addEventListener("resize", calculateRopeWidth);

    function calculateRopeWidth() {
      if (!rope || !ropePath) return;
      if (window.innerWidth < 768) {
        rope.style.top = 0 + "px";
        rope.style.left = 0 + "px";
        rope.style.width = 0 + "px";
        rope.style.height = 0 + "px";
      }

      const from = document.querySelector(
        ".challenge-content > li:nth-child(1) .aspect-square"
      ) as HTMLLIElement;
      const to = document.querySelector(
        ".challenge-content > li:nth-last-child(1) .aspect-square"
      ) as HTMLLIElement;

      const ropeTop = from.offsetTop + from.offsetHeight / 4;
      const ropeLeft = from.offsetLeft + from.getBoundingClientRect().width / 2;
      const ropeWidth = to.offsetLeft - ropeLeft;
      const ropeHeight = to.offsetHeight * (5 / 3);

      rope.style.top = ropeTop + "px";
      rope.style.left = ropeLeft + "px";
      rope.style.width = ropeWidth - ropeXTranslation + "px";
      rope.style.height = ropeHeight + "px";
    }
  }
</script>
